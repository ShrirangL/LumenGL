

// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Application.cpp =====
ï»¿#include "IndexBuffer.h"
#include "Texture.h"
#include "VertexBufferLayout.h"
#include "VertexArray.h"
#include "VertexBuffer.h"
#include "VertexBufferLayoutElement.h"
#include "Program.h"
#include "Renderer.h"
#include "Cuboid.h"
#include "Sphere.h"
#include "Cylinder.h"
#include "Grid.h"
#include "Globals.h"
#include "Line.h"

using namespace std;

int main()
{
	GLFWwindow* window = InitOpenGL();

	//std::vector<Sphere> solarSystem;

	Sphere sun(28.53);
	sun.setColor(255.0/255, 170.0/255, 29.0/255);
	sun.setPrograms(vertexShaderSource.data(), oldFragmentShaderSource.data(),
		vertexShaderSource.data(), edgeFragmentShaderSource.data());

	Sphere mercury(0.1, Point(0.0, 0.0f, 30.53));
	mercury.setColor(glm::vec3(0.55, 0.53, 0.50));
	mercury.setPrograms(vertexShaderSource.data(), fragmentShaderSource.data(),
		vertexShaderSource.data(), edgeFragmentShaderSource.data());
	//solarSystem.push_back(mercury);

	Sphere venus(0.248, Point(0.0f, 0.0f, 32.27));
	venus.setColor(glm::vec3(0.90, 0.72, 0.42));
	venus.setPrograms(vertexShaderSource.data(), fragmentShaderSource.data(),
		vertexShaderSource.data(), edgeFragmentShaderSource.data());
	//solarSystem.push_back(venus);

	Sphere earth(0.261, Point(0.0f, 0.0f, 33.70));
	earth.setColor(glm::vec3(0.24, 0.49, 0.91));
	earth.setPrograms(vertexShaderSource.data(), fragmentShaderSource.data(),
		vertexShaderSource.data(), edgeFragmentShaderSource.data());
	//solarSystem.push_back(earth);

	Sphere mars(0.139, Point(0.0f, 0.0f, 36.40));
	mars.setColor(glm::vec3(0.80, 0.36, 0.23));
	mars.setPrograms(vertexShaderSource.data(), fragmentShaderSource.data(),
		vertexShaderSource.data(), edgeFragmentShaderSource.data());

	Sphere jupiter(2.863, Point(0.0f, 0.0f, 55.42));
	jupiter.setColor(glm::vec3(0.87, 0.62, 0.43));
	jupiter.setPrograms(vertexShaderSource.data(), fragmentShaderSource.data(),
		vertexShaderSource.data(), edgeFragmentShaderSource.data());

	Sphere saturn(2.387, Point(0.0f, 0.0f, 78.05));
	saturn.setColor(glm::vec3(0.93, 0.85, 0.60));
	saturn.setPrograms(vertexShaderSource.data(), fragmentShaderSource.data(),
		vertexShaderSource.data(), edgeFragmentShaderSource.data());

	Sphere uranus(1.045, Point(0.0f, 0.0f, 127.63));
	uranus.setColor(glm::vec3(0.56, 0.75, 0.83));
	uranus.setPrograms(vertexShaderSource.data(), fragmentShaderSource.data(),
		vertexShaderSource.data(), edgeFragmentShaderSource.data());

	Sphere neptune(1.017, Point(0.0f, 0.0f, 183.83));
	neptune.setColor(glm::vec3(0.28, 0.36, 0.74));
	neptune.setPrograms(vertexShaderSource.data(), fragmentShaderSource.data(),
		vertexShaderSource.data(), edgeFragmentShaderSource.data());

	//Grid grid(40, 10, Point(0.0f, 0.0f, 0.0f));
	//grid.setPrograms(oldVertexShaderSource.data(), edgeFragmentShaderSource.data(),
	//	oldVertexShaderSource.data(), edgeFragmentShaderSource.data());

	//Main loop
	while (!glfwWindowShouldClose(window))
	{
		processInput(window);
		Renderer::getInstance().clear();

		//grid.draw2D();

		sun.draw3D();

		mercury.draw3D();
		venus.draw3D();
		earth.draw3D();
		mars.draw3D();
		jupiter.draw3D();
		saturn.draw3D();
		uranus.draw3D();
		neptune.draw3D();

		//for (Sphere& planet : solarSystem)
		//	planet.draw3D();

		//ratating cylinder around Y every frame
		mercury.rotateAroundYaxis(0.26);
		mercury.revolveAroundYaxis(Point(0.0f, 0.0f, 0.0f), 4.09);

		venus.rotateAroundYaxis(-0.06);
		venus.revolveAroundYaxis(Point(0.0f, 0.0f, 0.0f), 1.60);

		earth.rotateAroundYaxis(15.0);
		earth.revolveAroundYaxis(Point(0.0f, 0.0f, 0.0f), 1.0);

		mars.rotateAroundYaxis(14.6);
		mars.revolveAroundYaxis(Point(0.0f, 0.0f, 0.0f), 0.53);

		jupiter.rotateAroundYaxis(36.36);
		jupiter.revolveAroundYaxis(Point(0.0f, 0.0f, 0.0f), 0.084);

		saturn.rotateAroundYaxis(33.64);
		saturn.revolveAroundYaxis(Point(0.0f, 0.0f, 0.0f), 0.034);

		uranus.rotateAroundYaxis(-20.93);
		uranus.revolveAroundYaxis(Point(0.0f, 0.0f, 0.0f), 0.012);

		neptune.rotateAroundYaxis(22.36);
		neptune.revolveAroundYaxis(Point(0.0f, 0.0f, 0.0f), 0.006);

		glfwSwapBuffers(window);
		glfwPollEvents();
	}

	glfwDestroyWindow(window);
	glfwTerminate();
	return 0;
}

// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Circle.cpp =====
#include "Circle.h"
#include "glm/glm.hpp"
#include <glm/gtc/constants.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/epsilon.hpp>

Circle::Circle()
	: Shape(), mRadius(1.0), mNormal(0.0, 0.0, 1.0)
{
	Shape::build();
}

Circle::Circle(float radius)
	: Shape(), mRadius(radius), mNormal(0.0, 0.0, 1.0)
{
	Shape::build();
}

Circle::Circle(float x, float y, float z, float radius)
	: Shape(x, y, z), mRadius(radius), mNormal(0.0, 0.0, 1.0)
{
}

Circle::Circle(const Point& centre, float radius)
	: Shape(centre), mRadius(radius), mNormal(0.0, 0.0, 1.0)
{
	Shape::build();
}

Circle::Circle(const Point& centre, float radius, const Vector& normal)
	: Shape(centre), mRadius(radius), mNormal(normal)
{
	Shape::build();
}

void Circle::setLayout()
{
	Shape::setVBLLayout3Floats();
}

void Circle::generateVerticesAndIndices()
{
    glm::vec3 n = glm::normalize(glm::vec3(mNormal.x, mNormal.y, mNormal.z));
    glm::vec3 tangent;

    // Pick an arbitrary vector that's not parallel to the normal
    if (glm::all(glm::epsilonEqual(n, glm::vec3(0.0f, 0.0f, 1.0f), 1e-4f))) {
        tangent = glm::vec3(1, 0, 0);
    }
    else {
        tangent = glm::normalize(glm::cross(n, glm::vec3(0, 0, 1)));
    }

    glm::vec3 bitangent = glm::cross(n, tangent);

    std::vector<glm::vec3> vertices;
    for (int i = 0; i < 100; ++i) {
        float angle = glm::two_pi<float>() * i / 100;
        glm::vec3 point = mCentre
            + mRadius * cos(angle) * tangent
            + mRadius * sin(angle) * bitangent;
        mVertices.push_back(point.x);
        mVertices.push_back(point.y);
        mVertices.push_back(point.z);
    }
}






// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Circle.h =====
#pragma once

#include "Shape.h"

class Circle : public Shape
{
	float mRadius;
	Vector mNormal;
public:
	Circle();
	Circle(float radius);
	Circle(float x, float y, float z, float radius);
	Circle(const Point& centre, float radius);
	Circle(const Point& centre, float radius, const Vector& normal);

	void setLayout() override;
	void generateVerticesAndIndices() override;
};

// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Cuboid.cpp =====
#include "Cuboid.h"
#include <array>

Cuboid::Cuboid(float width, float height, float depth)
	: Shape(), mWidth(width), mHeight(height), mDepth(depth)
{
	Shape::build();
}

Cuboid::Cuboid(float width, float height, float depth, const Point& centre)
	: Shape(centre), mWidth(width), mHeight(height), mDepth(depth)
{
	Shape::build();
}

Cuboid::Cuboid(float width, float height, float depth, float x, float y, float z)
	: Shape(x,y,z), mWidth(width), mHeight(height), mDepth(depth)
{
	Shape::build();
}

void Cuboid::generateVerticesAndIndices()
{
	mVertices.clear();
	mIndices.clear();

	float w = mWidth / 2.0f;
	float h = mHeight / 2.0f;
	float d = mDepth / 2.0f;

	// 8 corner vertices (in world space)
	std::vector<glm::vec3> corners = {
		{mCentre.x - w, mCentre.y - h, mCentre.z - d}, // 0: left-bottom-back
		{mCentre.x + w, mCentre.y - h, mCentre.z - d}, // 1: right-bottom-back
		{mCentre.x + w, mCentre.y + h, mCentre.z - d}, // 2: right-top-back
		{mCentre.x - w, mCentre.y + h, mCentre.z - d}, // 3: left-top-back
		{mCentre.x - w, mCentre.y - h, mCentre.z + d}, // 4: left-bottom-front
		{mCentre.x + w, mCentre.y - h, mCentre.z + d}, // 5: right-bottom-front
		{mCentre.x + w, mCentre.y + h, mCentre.z + d}, // 6: right-top-front
		{mCentre.x - w, mCentre.y + h, mCentre.z + d}  // 7: left-top-front
	};

	// List of triangle indices (2 per face)
	std::vector<std::array<int, 3>> triangles = {
		// Back face
		{0, 1, 2}, {2, 3, 0},
		// Front face
		{4, 6, 5}, {6, 4, 7},
		// Left face
		{0, 3, 7}, {7, 4, 0},
		// Right face
		{1, 5, 6}, {6, 2, 1},
		// Bottom face
		{0, 4, 5}, {5, 1, 0},
		// Top face
		{3, 2, 6}, {6, 7, 3}
	};

	// For each triangle: compute face normal and store 3 vertices (position + normal)
	for (const auto& tri : triangles)
	{
		glm::vec3 v0 = corners[tri[0]];
		glm::vec3 v1 = corners[tri[1]];
		glm::vec3 v2 = corners[tri[2]];

		glm::vec3 edge1 = v1 - v0;
		glm::vec3 edge2 = v2 - v0;
		glm::vec3 normal = glm::normalize(glm::cross(edge1, edge2));

		// Append each vertex with its normal (per-face flat shading)
		auto addVertex = [&](const glm::vec3& v) {
			mVertices.push_back(v.x);
			mVertices.push_back(v.y);
			mVertices.push_back(v.z);
			mVertices.push_back(normal.x);
			mVertices.push_back(normal.y);
			mVertices.push_back(normal.z);
			};

		addVertex(v0);
		addVertex(v1);
		addVertex(v2);
	}

	// Optional: You can remove mIndices if using glDrawArrays
	// If using glDrawElements, fill mIndices like this:
	for (int i = 0; i < mVertices.size() / 6; ++i)
		mIndices.push_back(i);
}



// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Cuboid.h =====
#pragma once

#include "Shape.h"

class Cuboid : public Shape
{
	float mWidth, mHeight, mDepth;
public:
	Cuboid(float width, float height, float depth);
	Cuboid(float width, float height, float depth, const Point& centre);
	Cuboid(float width, float height, float depth, float centreX, float centreY, float centreZ);

	void generateVerticesAndIndices() override;
};

// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Cylinder.cpp =====
#include "Cylinder.h"

Cylinder::Cylinder(float height, float radius)
	: Shape(), topCentre(0.0, height / 2, 0.0), bottomCentre(0.0, -height / 2, 0.0), height(height), radius(radius)
{
	Shape::build();
}

Cylinder::Cylinder(const Point& point, float height, float radius)
	: Shape(point.x, point.y+height/2, point.z), topCentre(point.x, point.y+height, point.z), bottomCentre(point), height(height), radius(radius)
{
	Shape::build();
}

void Cylinder::generateVerticesAndIndices()
{
    const int segments = 32; // Number of segments to approximate the circle
    const float angleStep = 2.0f * PI / segments;

    mVertices.clear();
    mIndices.clear();

    // Compute top and bottom centers
    Point center = mCentre;  // From base class
    float halfHeight = height / 2.0f;

    Point topCenter(center.x, center.y + halfHeight, center.z);
    Point bottomCenter(center.x, center.y - halfHeight, center.z);

    // Indices for the center points in the vertex list
    unsigned int topCenterIndex = 0;
    unsigned int bottomCenterIndex = 1;

    // Add top and bottom center points
    mVertices.insert(mVertices.end(), { topCenter.x, topCenter.y, topCenter.z });
    mVertices.insert(mVertices.end(), { bottomCenter.x, bottomCenter.y, bottomCenter.z });

    // Add ring vertices (top and bottom)
    for (int i = 0; i <= segments; ++i) // <= to close the loop
    {
        float angle = i * angleStep;
        float x = radius * cos(angle);
        float z = radius * sin(angle);

        // Top ring vertex
        mVertices.insert(mVertices.end(), { center.x + x, topCenter.y, center.z + z });

        // Bottom ring vertex
        mVertices.insert(mVertices.end(), { center.x + x, bottomCenter.y, center.z + z });
    }

    // Top cap triangles
    for (int i = 0; i < segments; ++i)
    {
        unsigned int ringTopStart = 2; // After 2 center vertices
        mIndices.push_back(topCenterIndex);
        mIndices.push_back(ringTopStart + i * 2);       // current top ring vertex
        mIndices.push_back(ringTopStart + (i + 1) * 2); // next top ring vertex
    }

    // Bottom cap triangles
    for (int i = 0; i < segments; ++i)
    {
        unsigned int ringBottomStart = 3; // second vertex in the pair (after center)
        mIndices.push_back(bottomCenterIndex);
        mIndices.push_back(ringBottomStart + (i + 1) * 2); // next bottom ring vertex
        mIndices.push_back(ringBottomStart + i * 2);       // current bottom ring vertex
    }

    // Side surface as quads (2 triangles per segment)
    for (int i = 0; i < segments; ++i)
    {
        unsigned int ringStart = 2;
        unsigned int top1 = ringStart + i * 2;
        unsigned int bottom1 = ringStart + i * 2 + 1;
        unsigned int top2 = ringStart + (i + 1) * 2;
        unsigned int bottom2 = ringStart + (i + 1) * 2 + 1;

        // Triangle 1
        mIndices.push_back(top1);
        mIndices.push_back(bottom1);
        mIndices.push_back(top2);

        // Triangle 2
        mIndices.push_back(top2);
        mIndices.push_back(bottom1);
        mIndices.push_back(bottom2);
    }
}



// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Cylinder.h =====
#pragma once

#include "Shape.h"
#include "Point.h"

class Cylinder : public Shape
{
	Point topCentre, bottomCentre;
	float height;
	float radius;
public:
	Cylinder(float height, float radius);
	Cylinder(const Point& point, float height, float radius);

	void generateVerticesAndIndices() override;
};

// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Globals.cpp =====
#include "Globals.h"
#include <iostream>

//Light Source
glm::vec3 gLightPos = glm::vec3(0.0f, 0.0f, 0.0f);
glm::vec3 gLightColor = glm::vec3(1.0f, 1.0f, 1.0f); // white light

// Camera
glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 190.0f);
glm::vec3 cameraFront = glm::normalize(glm::vec3(0.0f, 0.0f, 0.0f) - cameraPos);
glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f);

float deltaTime = 0.0f;
float lastFrame = 0.0f;

float lastX = 800.0f, lastY = 600.0f; // Initial center of screen
bool firstMouse = true;

float fieldOfView = 45.0f;

float horizontalAngle = -90.0f; // Facing -Z initially
float verticalAngle = 0.0f;
float sensitivity = 0.05f; // Degrees per key press

glm::mat4 gView = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);

float screenWidth = 800.0f;
float screenHeight = 600.0f;
float nearDistance = 0.1f;
float farDistance = 300.0f;
glm::mat4 gProjection = glm::perspective(glm::radians(fieldOfView), screenWidth / screenHeight, nearDistance, farDistance);

std::string oldVertexShaderSource =
"#version 330 core\n"
"layout(location = 0) in vec3 aPos;\n"
"uniform mat4 model;\n"
"uniform mat4 view;\n"
"uniform mat4 projection;\n"
"void main() {\n"
"    gl_Position = projection * view * model * vec4(aPos, 1.0);\n"
"}\n";

std::string oldFragmentShaderSource = R"glsl(
#version 330 core
out vec3 FragColor;

void main() {
	FragColor = vec3(1.0, 0.9, 0.3); // Sun color
}
)glsl";


std::string edgeFragmentShaderSource =
"#version 330 core\n"
"out vec4 FragColor;\n"
"void main(){\n"
"	FragColor = vec4(0.0, 0.0, 0.0, 1.0); // Black edges\n"
"}\n";

std::string vertexShaderSource = R"glsl(
#version 330 core

layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aNormal;
layout(location = 2) in vec2 aTexCoord;

out vec2 vTexCoord;
out vec3 FragPos;
out vec3 Normal;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
	FragPos = aPos;        // Already in world space
	Normal = aNormal;      // Already in world space
	vTexCoord = aTexCoord;
	gl_Position = projection * view * model * vec4(aPos, 1.0);
}
)glsl";

std::string fragmentShaderSource = R"glsl(
#version 330 core

in vec3 FragPos;
in vec3 Normal;
in vec2 vTexCoord;

out vec4 FragColor;

uniform sampler2D u_Texture;
uniform bool u_UseTexture;

uniform vec3 lightPos;
uniform vec3 viewPos;
uniform vec3 lightColor;
uniform vec3 objectColor;

void main()
{
    // Ambient
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;

    // Diffuse
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;

    // Specular
    float specularStrength = 0.5;
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
    vec3 specular = specularStrength * spec * lightColor;

	if (u_UseTexture)
	{
        vec3 textureColor = texture(u_Texture, vTexCoord).rgb;
		vec3 result = (ambient + diffuse + specular) * textureColor;
		FragColor = vec4(result, 1.0);
	}
    else
	{
        vec3 result = (ambient + diffuse + specular) * objectColor;
		FragColor = vec4(result, 1.0);
	}
}
)glsl";

void processInput(GLFWwindow* window)
{
	float currentFrame = glfwGetTime();
	deltaTime = currentFrame - lastFrame;
	lastFrame = currentFrame;

	float cameraSpeed = 2.5f * deltaTime;

	// Movement
	if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
		cameraPos += cameraSpeed * cameraFront;
	if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
		cameraPos -= cameraSpeed * cameraFront;
	if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
		cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
	if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
		cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;

	// Rotation
	if (glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS)
		horizontalAngle -= sensitivity;
	if (glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS)
		horizontalAngle += sensitivity;
	if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS)
		verticalAngle += sensitivity;
	if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS)
		verticalAngle -= sensitivity;

	// Clamp pitch
	if (verticalAngle > 89.0f)
		verticalAngle = 89.0f;
	if (verticalAngle < -89.0f)
		verticalAngle = -89.0f;

	// Update cameraFront based on yaw and pitch
	glm::vec3 front;
	front.x = cos(glm::radians(horizontalAngle)) * cos(glm::radians(verticalAngle));
	front.y = sin(glm::radians(verticalAngle));
	front.z = sin(glm::radians(horizontalAngle)) * cos(glm::radians(verticalAngle));
	cameraFront = glm::normalize(front);

	gView = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
}

GLFWwindow* InitOpenGL()
{
	//Initialize GLFW
	if (!glfwInit())
	{
		std::cerr << "Failed to intitalize GLFW" << std::endl;
		exit(-1);
	}

	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

	GLFWwindow* window = glfwCreateWindow(1600, 1200, "Model", nullptr, nullptr);
	if (!window)
	{
		std::cerr << "Failed to create window" << std::endl;
		glfwTerminate();
		exit(-1);
	}

	glfwMakeContextCurrent(window);

	//initialize glew
	if (glewInit() != GLEW_OK)
	{
		std::cerr << "Failed to initialize glew" << std::endl;
		exit(-1);
	}

	glEnable(GL_DEPTH_TEST);

	glfwSetCursorPosCallback(window, mouse_callback);
	glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // hides and locks cursor

	glfwSetScrollCallback(window, scroll_callback);

	return window;
}

void mouse_callback(GLFWwindow* window, double xpos, double ypos)
{
	if (firstMouse)
	{
		lastX = xpos;
		lastY = ypos;
		firstMouse = false;
	}

	float xoffset = xpos - lastX;
	float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top
	lastX = xpos;
	lastY = ypos;

	xoffset *= sensitivity;
	yoffset *= sensitivity;

	horizontalAngle += xoffset;
	verticalAngle += yoffset;

	// Clamp pitch
	if (verticalAngle > 89.0f)
		verticalAngle = 89.0f;
	if (verticalAngle < -89.0f)
		verticalAngle = -89.0f;

	glm::vec3 front;
	front.x = cos(glm::radians(horizontalAngle)) * cos(glm::radians(verticalAngle));
	front.y = sin(glm::radians(verticalAngle));
	front.z = sin(glm::radians(horizontalAngle)) * cos(glm::radians(verticalAngle));
	cameraFront = glm::normalize(front);

	gView = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
}

void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
{
	fieldOfView -= (float)yoffset;
	if (fieldOfView < 1.0f)
		fieldOfView = 1.0f;
	if (fieldOfView > 45.0f)
		fieldOfView = 45.0f;

	gProjection = glm::perspective(glm::radians(fieldOfView), screenWidth / screenHeight, nearDistance, farDistance);
}

// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Globals.h =====
#pragma once

#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <string>

//Light Source
extern glm::vec3 gLightPos;
extern glm::vec3 gLightColor;

// Camera
extern glm::vec3 cameraPos;
extern glm::vec3 cameraFront;
extern glm::vec3 cameraUp;
extern float deltaTime;
extern float lastFrame;

extern float lastX;
extern float lastY; // Initial center of screen
extern bool firstMouse;

extern float fieldOfView;

extern float horizontalAngle; // Facing -Z initially
extern float verticalAngle;
extern float sensitivity; // Degrees per key press

extern glm::mat4 gView;
extern glm::mat4 gProjection;

extern std::string oldVertexShaderSource;
extern std::string oldFragmentShaderSource;
extern std::string edgeFragmentShaderSource;

extern std::string vertexShaderSource;
extern std::string fragmentShaderSource;

void processInput(GLFWwindow* window);
GLFWwindow* InitOpenGL();

void mouse_callback(GLFWwindow* window, double xpos, double ypos);
void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);

// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Grid.cpp =====
#include "Grid.h"

Grid::Grid(int lines, float spacing)
    : Shape(), numLines(lines), spacing(spacing)
{
    build();
}

Grid::Grid(int lines, float spacing, const Point& centre)
    : Shape(centre), numLines(lines), spacing(spacing)
{
    build();
}

void Grid::setLayout()
{
    Shape::setVBLLayout3Floats();
}

void Grid::generateVerticesAndIndices()
{
    mVertices.clear();
    mIndices.clear();

    int half = numLines / 2;
    unsigned int index = 0;

    for (int i = -half; i <= half; ++i)
    {
        float coord = i * spacing;

        // Lines parallel to Z axis (constant X)
        mVertices.push_back(coord); mVertices.push_back(0.0f); mVertices.push_back(-half * spacing); // start
        mVertices.push_back(coord); mVertices.push_back(0.0f); mVertices.push_back(half * spacing);  // end

        mIndices.push_back(index++);
        mIndices.push_back(index++);

        // Lines parallel to X axis (constant Z)
        mVertices.push_back(-half * spacing); mVertices.push_back(0.0f); mVertices.push_back(coord); // start
        mVertices.push_back(half * spacing);  mVertices.push_back(0.0f); mVertices.push_back(coord); // end

        mIndices.push_back(index++);
        mIndices.push_back(index++);
    }
}


// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Grid.h =====
#pragma once

#pragma once
#include "Shape.h"

class Grid : public Shape
{
    int numLines;
    float spacing;
public:
    Grid(int lines = 20, float spacing = 1.0f);
    Grid(int lines, float spacing, const Point& centre);
    void setLayout() override;

    void generateVerticesAndIndices() override;
};


// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\IndexBuffer.cpp =====
#include "IndexBuffer.h"
#include <GL/glew.h>

IndexBuffer::IndexBuffer()
	: count(0)
{
	glGenBuffers(1, &ID);
}

IndexBuffer::IndexBuffer(const unsigned int* data, unsigned int cnt)
	: count(cnt)
{
	glGenBuffers(1, &ID);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ID);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, count * sizeof(unsigned int), data, GL_STATIC_DRAW);
}

IndexBuffer::~IndexBuffer()
{
	glDeleteBuffers(1, &ID);
}

void IndexBuffer::setDataAndCount(const unsigned int* data, unsigned int cnt)
{
	count = cnt;
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ID);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, count * sizeof(unsigned int), data, GL_STATIC_DRAW);
}

void IndexBuffer::bind() const
{
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ID);
}

void IndexBuffer::unbind() const
{
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
}

unsigned int IndexBuffer::getCount() const
{
	return count;
}

// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\IndexBuffer.h =====
#pragma once

class IndexBuffer
{
	unsigned int ID;
	unsigned int count;
public:
	IndexBuffer();
	IndexBuffer(const unsigned int* data, unsigned int cnt);
	~IndexBuffer();

	void setDataAndCount(const unsigned int* data, unsigned int cnt);
	void bind() const;
	void unbind() const;
	unsigned int getCount() const;
};


// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Line.cpp =====
#include "Line.h"

Line::Line() 
	: start(), end() 
{
	Shape::build();
}

Line::Line(const Point& start, const Point& end)
	: start(start), end(end) 
{
	Shape::build();
} 

Line::Line(float stX, float stY, float stZ, float endX, float endY, float endZ)
	:start(stX, stY, stZ), end(endX, endY, endZ) 
{
	Shape::build();
}

void Line::setLayout()
{
	Shape::setVBLLayout3Floats();
}

void Line::generateVerticesAndIndices()
{
	mVertices.push_back(start.x);
	mVertices.push_back(start.y);
	mVertices.push_back(start.z);

	mVertices.push_back(end.x);
	mVertices.push_back(end.y);
	mVertices.push_back(end.z);

	mIndices.push_back(0);
	mIndices.push_back(1);
}


// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Line.h =====
#pragma once
#include "Point.h"
#include "Shape.h"

struct Line : public Shape
{
	Point start, end;

	Line();
	Line(const Point& start, const Point& end);
	Line(float stX, float stY, float stZ, float endX, float endY, float endZ);

	void setLayout() override;
	void generateVerticesAndIndices() override;
};

// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Point.h =====
#pragma once

#include <glm/glm.hpp>

struct Point
{
	float x, y, z;
	Point() : x(0.0f), y(0.0f), z(0.0f) {}
	Point(float f) : x(f), y(f), z(f) {}
	Point(float x, float y, float z) : x(x), y(y), z(z) {}
	Point(const Point& other) : x(other.x), y(other.y), z(other.z) {}
	Point(const glm::vec3& other) : x(other.x), y(other.y), z(other.z) {}

	Point operator+(const Point& other) const
	{
		return Point(x + other.x, y + other.y, z + other.z);
	}

	// Conversion operator to glm::vec3
	operator glm::vec3() const {
		return glm::vec3(x, y, z);
	}
};

typedef Point Vector;

// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Program.cpp =====
#include "Program.h"
#include <GL/glew.h>
#include <glm/gtc/type_ptr.hpp>

Program::Program()
{
	ID = glCreateProgram();
	setVertexAndFragmentSources(nullptr, nullptr);
}

Program::Program(const char* vertexSource, const char* fragmentSource)
{
	ID = glCreateProgram();

	setVertexAndFragmentSources(vertexSource, fragmentSource);
}

void Program::setVertexAndFragmentSources(const char* vertexSource, const char* fragmentSource)
{
	if (vertexSource || fragmentSource)
	{
		//Create and compile vertex shader
		unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);

		if (vertexSource)
		{
			glShaderSource(vertexShader, 1, &vertexSource, nullptr);
			glCompileShader(vertexShader);
		}

		//Create and compile fragment shader
		unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);

		if (fragmentSource)
		{
			glShaderSource(fragmentShader, 1, &fragmentSource, nullptr);
			glCompileShader(fragmentShader);
		}

		//Link shaders into program
		glAttachShader(ID, vertexShader);
		glAttachShader(ID, fragmentShader);
		glLinkProgram(ID);

		glDeleteShader(vertexShader);
		glDeleteShader(fragmentShader);
	}
}

std::string Program::getVertexShaderSource() const
{
	return mVertexShaderSource;
}

std::string Program::getFragmentShaderSource() const
{
	return mVertexShaderSource;
}

void Program::use() const
{
	glUseProgram(ID);
}

void Program::setUniform1i(const char* name, int value)
{
	use();
	glUniform1i(glGetUniformLocation(ID, name), value);
}

void Program::setUniform1f(const char* name, float value) 
{
	use();
	glUniform1f(glGetUniformLocation(ID, name), value);
}

void Program::setUniform3f(const char* name, float v0, float v1, float v2) 
{
	use();
	glUniform3f(glGetUniformLocation(ID, name), v0, v1, v2);
}

void Program::setUniformVector3fv(const char* name, const glm::vec3& vec)
{
	use();
	glUniform3fv(glGetUniformLocation(ID, name), 1, &vec[0]);
}


void Program::setUniformMatrix3fv(const char* name, const glm::mat3& matrix)
{
	use();
	glUniformMatrix3fv(glGetUniformLocation(ID, name),1, GL_FALSE, &matrix[0][0]);
}

void Program::setUniform4f(const char* name, float v0, float v1, float v2, float v3)
{
	use();
	glUniform4f(glGetUniformLocation(ID, name), v0, v1, v2, v3);
}

void Program::setUniformMatrix4fv(const char* name, const glm::mat4& matrix)
{
	use();
	glUniformMatrix4fv(glGetUniformLocation(ID, name), 1, GL_FALSE, &matrix[0][0]);
}




// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Program.h =====
#pragma once

#include <unordered_map>
#include <string>
#include <glm/glm.hpp>

class Program
{
	unsigned int ID;
	std::string mVertexShaderSource;
	std::string mFragmentShaderSource;
	std::unordered_map<std::string, unsigned int> uniforms;

public:
	Program();
	Program(const char* vertexSource, const char* fragmentSource);
	void setVertexAndFragmentSources(const char* vertexSource, const char* fragmentSource);
	std::string getVertexShaderSource() const;
	std::string getFragmentShaderSource() const;
	void use() const;
	void setUniform1i(const char* name, int value);
	void setUniform1f(const char* name, float value);
	void setUniform3f(const char* name, float v0, float v1, float v2);
	void setUniformVector3fv(const char* name, const glm::vec3& vec);
	void setUniformMatrix3fv(const char* name, const glm::mat3& matrix);
	void setUniform4f(const char* name, float v0, float v1, float v2, float v3);
	void setUniformMatrix4fv(const char* name, const glm::mat4& matrix);
};

// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Rectangle.cpp =====


// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Renderer.cpp =====
#include "Renderer.h"
#include <GL/glew.h>
#include "VertexArray.h"
#include "IndexBuffer.h"
#include "Program.h"

Renderer::Renderer() {}

Renderer& Renderer::getInstance()
{
	static Renderer instance;
	return instance;
}

void Renderer::clear() const
{
	glClearColor(0.2f, 0.2f, 0.2f, 1.0f); // Grey background
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);;
}

void Renderer::draw(const VertexArray& va, const VertexBuffer& vb, const IndexBuffer* ib, const Program& fillProgram, const Program* edgeProgram,
	FillMode fillMode, unsigned int drawMode) const
{
	va.bind();

	switch (fillMode) {
	case FILL:
		fillProgram.use();
		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
		draw(drawMode, ib, vb.getCount());
		break;

	case EDGE:
		if (edgeProgram) {
			edgeProgram->use();
			glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
			draw(drawMode, ib, vb.getCount());
		}
		break;

	case FILL_AND_EDGE:
		// Fill pass
		fillProgram.use();
		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
		draw(drawMode, ib, vb.getCount());

		// Edge pass (with slight offset to avoid z-fighting)
		if (edgeProgram) {
			glEnable(GL_POLYGON_OFFSET_LINE);
			glPolygonOffset(-1.0f, -1.0f);

			edgeProgram->use();
			glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
			draw(drawMode, ib, vb.getCount());

			glDisable(GL_POLYGON_OFFSET_LINE);     // Clean up state
		}
		break;
	}
}

void Renderer::draw(unsigned int drawMode, const IndexBuffer* ib, unsigned int vertexCount) const
{
	if (ib)
	{
		ib->bind();
		glDrawElements(drawMode, ib->getCount(), GL_UNSIGNED_INT, nullptr);
	}
	else
	{
		glDrawArrays(drawMode, 0, vertexCount);
	}
}


// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Renderer.h =====
#pragma once

class VertexArray;
class VertexBuffer;
class IndexBuffer;
class Program;

enum FillMode
{
	FILL = 0, EDGE, FILL_AND_EDGE
};

class Renderer
{
	Renderer();
	Renderer(const Renderer& other) = delete;
	Renderer& operator=(const Renderer& other) = delete;
public:
	static Renderer& getInstance();
	void clear() const;
	void draw(const VertexArray& va, const VertexBuffer& vb, const IndexBuffer* ib, const Program& fillProgram, const Program* edgeProgram, FillMode fillMode, unsigned int drawMode) const;
	void draw(unsigned int drawMode, const IndexBuffer* ib, unsigned int vertexCount) const;
};

// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Shape.cpp =====
#include "Shape.h"

void Shape::setVBDataSizeAndCount()
{
	mVB.setDataSizeAndCount(mVertices.data(), mVertices.size() * sizeof(float), mVertices.size() / 3);
}

void Shape::setVBLLayout3Floats()
{
	mVBL.push<float>(3);
}
void Shape::setVBLLayout3Pos3Norm()
{
	mVBL.push<float>(3);
	mVBL.push<float>(3);
}

void Shape::setVBLayout3Pos3Norm2Tex()
{
	mVBL.push<float>(3);
	mVBL.push<float>(3);
	mVBL.push<float>(2);
}

void Shape::setLayout()
{
	setVBLLayout3Pos3Norm();
}
void Shape::setVABufferAndLayout()
{
	mVA.addBufferAndLayout(mVB, mVBL);
}

void Shape::setIBDataAndSize()
{
	mIB.setDataAndCount(mIndices.data(), mIndices.size());
}

void Shape::build()
{
	generateVerticesAndIndices();

	setVBDataSizeAndCount();
	setLayout();
	setVABufferAndLayout();
	setIBDataAndSize();
}

Shape::Shape()
	: mCentre(), mModel(1.0f), mColor(0.0627f, 0.4863f, 0.0627f)
{
}

Shape::Shape(float x, float y, float z)
	: mCentre(x, y, z), mModel(1.0f), mColor(0.0627f, 0.4863f, 0.0627f)
{
}

Shape::Shape(const Point& centre)
	: mCentre(centre), mModel(1.0f), mColor(0.0627f, 0.4863f, 0.0627f)
{
}

Shape::Shape(const Point& centre, const glm::vec3& color)
	: mCentre(centre), mModel(1.0f), mColor(color)
{
}

Shape::Shape(float x, float y, float z, glm::mat4 mat)
	: mCentre(x, y, z), mModel(mat), mColor(0.0627f, 0.4863f, 0.0627f)
{
}

Shape::Shape(float x, float y, float z, glm::mat4 mat, const glm::vec3& color)
	: mCentre(x, y, z), mModel(mat), mColor(color)
{
}

Shape::~Shape()
{
	delete mTexture;
}

void Shape::setPrograms(const Program* const fill, const Program* const edge)
{
	fillProgram.setVertexAndFragmentSources(fill->getVertexShaderSource().data(), fill->getFragmentShaderSource().data());
	edgeProgram.setVertexAndFragmentSources(edge->getVertexShaderSource().data(), edge->getFragmentShaderSource().data());

	setStaticUniforms();
}

void Shape::setFillProgram(const Program* const fill)
{
	fillProgram.setVertexAndFragmentSources(fill->getVertexShaderSource().data(), fill->getFragmentShaderSource().data());

	setStaticUniforms();
}

void Shape::setEdgeProgram(const Program* const edge)
{
	edgeProgram.setVertexAndFragmentSources(edge->getVertexShaderSource().data(), edge->getFragmentShaderSource().data());

	setStaticUniforms();
}

void Shape::setPrograms(const char* fillVertexSrc, const char* fillFragmentSrc, const char* edgeVertexSrc, const char* edgeFragmentSrc)
{
	fillProgram.setVertexAndFragmentSources(fillVertexSrc, fillFragmentSrc);
	edgeProgram.setVertexAndFragmentSources(edgeVertexSrc, edgeFragmentSrc);

	setStaticUniforms();
}

void Shape::setFillProgram(const char* fillVertexSrc, const char* fillFragmentSrc)
{
	fillProgram.setVertexAndFragmentSources(fillVertexSrc, fillFragmentSrc);

	setStaticUniforms();
}

void Shape::setEdgeProgram(const char* edgeVertexSrc, const char* edgeFragmentSrc)
{
	edgeProgram.setVertexAndFragmentSources(edgeVertexSrc, edgeFragmentSrc);

	setStaticUniforms();
}

void Shape::setModelMatrix(const glm::mat4& matrix)
{
	mModel = matrix;
	fillProgram.setUniformMatrix4fv("model", mModel);
	edgeProgram.setUniformMatrix4fv("model", mModel);
}

void Shape::setViewMatrix(const glm::mat4& matrix)
{
	fillProgram.setUniformMatrix4fv("view", matrix);
	edgeProgram.setUniformMatrix4fv("view", matrix);
}

void Shape::setProjectionMatrix(const glm::mat4& matrix)
{
	fillProgram.setUniformMatrix4fv("projection", matrix);
	edgeProgram.setUniformMatrix4fv("projection", matrix);
}

void Shape::setCameraViewPositionVector(const glm::vec3& vec)
{
	fillProgram.setUniformVector3fv("viewPos", vec);
	edgeProgram.setUniformVector3fv("viewPos", vec);
}

void Shape::setLightPositionVector(const glm::vec3& vec)
{
	fillProgram.setUniformVector3fv("lightPos", vec);
	edgeProgram.setUniformVector3fv("lightPos", vec);
}

void Shape::setLightColorVector(const glm::vec3& vec)
{
	fillProgram.setUniformVector3fv("lightColor", vec);
	edgeProgram.setUniformVector3fv("lightColor", vec);
}

void Shape::setObjectColorVector(const glm::vec3& vec)
{
	fillProgram.setUniformVector3fv("objectColor", vec);
	edgeProgram.setUniformVector3fv("objectColor", vec);
}

void Shape::setUniform1i(const char* name, int value)
{
	fillProgram.setUniform1i(name, value);
	edgeProgram.setUniform1i(name, value);
}

void Shape::setUniform1f(const char* name, float value)
{
	fillProgram.setUniform1f(name, value);
	edgeProgram.setUniform1f(name, value);
}

void Shape::setUniform3f(const char* name, float v0, float v1, float v2)
{
	fillProgram.setUniform3f(name, v0, v1, v2);
	edgeProgram.setUniform3f(name, v0, v1, v2);
}

void Shape::setUniformVector3fv(const char* name, const glm::vec3& vec)
{
	fillProgram.setUniformVector3fv(name, vec);
	edgeProgram.setUniformVector3fv(name, vec);
}

void Shape::setUniformMatrix4fv(const char* name, const glm::mat4& matrix)
{
	fillProgram.setUniformMatrix4fv(name, matrix);
	edgeProgram.setUniformMatrix4fv(name, matrix);
}

void Shape::setUniform1i(ShapeProgram prog, const char* name, int value)
{
	if (prog == ShapeProgram::SHAPE_FILL)
		fillProgram.setUniform1i(name, value);
	else
		edgeProgram.setUniform1i(name, value);
}

void Shape::setUniform1f(ShapeProgram prog, const char* name, float value)
{
	if (prog == ShapeProgram::SHAPE_FILL)
		fillProgram.setUniform1f(name, value);
	else
		edgeProgram.setUniform1f(name, value);
}

void Shape::setUniform3f(ShapeProgram prog, const char* name, float v0, float v1, float v2)
{
	if (prog == ShapeProgram::SHAPE_FILL)
		fillProgram.setUniform3f(name, v0, v1, v2);
	else
		edgeProgram.setUniform3f(name, v0, v1, v2);
}

void Shape::setUniformVector3fv(ShapeProgram prog, const char* name, const glm::vec3& vec)
{
	if (prog == ShapeProgram::SHAPE_FILL)
		fillProgram.setUniformVector3fv(name, vec);
	else
		edgeProgram.setUniformVector3fv(name, vec);
}

void Shape::setUniformMatrix4fv(ShapeProgram prog, const char* name, const glm::mat4& matrix)
{
	if (prog == ShapeProgram::SHAPE_FILL)
		fillProgram.setUniformMatrix4fv(name, matrix);
	else
		edgeProgram.setUniformMatrix4fv(name, matrix);
}

void Shape::setStaticUniforms()
{
	setModelMatrix(mModel);
	setLightPositionVector(gLightPos); //Light position doesn't change
	setLightColorVector(gLightColor); //Light color doesn't change
	setObjectColorVector(mColor); //Object color doesn't change
}

void Shape::setDynamicUniforms()
{
	setViewMatrix(gView);
	setProjectionMatrix(gProjection);
	setCameraViewPositionVector(cameraPos);
	setUseTexture();
}

void Shape::setAllUniforms()
{
	setStaticUniforms();
	setDynamicUniforms();
}

void Shape::setColor(float red, float green, float blue)
{
	mColor.x = red;
	mColor.y = green;
	mColor.z = blue;
	setObjectColorVector(mColor);
}

void Shape::setColor(const Point& color)
{
	mColor.x = color.x;
	mColor.y = color.y;
	mColor.z = color.z;
	setObjectColorVector(mColor);
}

void Shape::setColor(const glm::vec3& color)
{
	mColor = color;
	setObjectColorVector(mColor);
}

void Shape::setUseTexture()
{
	if (mHasTexture)
	{
		setUniform1i("u_UseTexture", 1);
		mTexture->bind(0);
		setUniform1i("u_Texture", 0);
	}
	else
		setUniform1i("u_UseTexture", 0);
}

void Shape::setTexture(Texture* texture)
{
	mTexture = texture;
	if (mTexture != nullptr)
	{
		mHasTexture = true;
		setUniform1i("u_UseTexture", 1);
	}
}

void Shape::setTexture(const std::string& path)
{
	mTexture = new Texture(path);
	if (mTexture != nullptr)
	{
		mHasTexture = true;
		setUniform1i("u_UseTexture", 1);
	}
}

void Shape::draw3D()
{
	setAllUniforms();

	Renderer::getInstance().draw(mVA, mVB, &mIB, fillProgram, &edgeProgram, FILL, GL_TRIANGLES);

	if (mHasTexture && mTexture != nullptr)
		mTexture->unBind();
}

void Shape::draw2D()
{
	setDynamicUniforms();
	Renderer::getInstance().draw(mVA, mVB, &mIB, fillProgram, &edgeProgram, EDGE, GL_LINES);
}

void Shape::rotateAroundAxis(const glm::vec3& axis, float angleDegrees)
{
	glm::vec3 centerVec(mCentre.x, mCentre.y, mCentre.z);
	glm::mat4 rotation = glm::rotate(glm::mat4(1.0f), glm::radians(angleDegrees), glm::normalize(axis));

	for (size_t i = 0; i < mVertices.size(); i += mVBL.getStride()) // step by 6 floats
	{
		// Position
		glm::vec3 vertex(mVertices[i], mVertices[i + 1], mVertices[i + 2]);
		vertex -= centerVec; // Translate to origin
		vertex = glm::vec3(rotation * glm::vec4(vertex, 1.0f)); // Rotate
		vertex += centerVec; // Translate back

		mVertices[i] = vertex.x;
		mVertices[i + 1] = vertex.y;
		mVertices[i + 2] = vertex.z;

		// Normal
		glm::vec3 normal(mVertices[i + 3], mVertices[i + 4], mVertices[i + 5]);
		normal = glm::vec3(rotation * glm::vec4(normal, 0.0f)); // Rotate normal only
		normal = glm::normalize(normal); // Normalize to be safe

		mVertices[i + 3] = normal.x;
		mVertices[i + 4] = normal.y;
		mVertices[i + 5] = normal.z;
	}

	setVBDataSizeAndCount(); // Upload new vertex positions (and normals) to GPU
}

void Shape::rotateAroundXaxis(float angleDegrees)
{
	rotateAroundAxis(glm::vec3(1.0f, 0.0f, 0.0f), angleDegrees);
}

void Shape::rotateAroundYaxis(float angleDegrees)
{
	rotateAroundAxis(glm::vec3(0.0f, 1.0f, 0.0f), angleDegrees);
}

void Shape::rotateAroundZaxis(float angleDegrees)
{
	rotateAroundAxis(glm::vec3(0.0f, 0.0f, 1.0f), angleDegrees);
}

void Shape::moveAlongVector(const glm::vec3& dir, float distance)
{
	glm::vec3 moveVec = glm::normalize(dir) * distance;

	// Translate all vertices
	for (size_t i = 0; i < mVertices.size(); i += 3)
	{
		mVertices[i] += moveVec.x;
		mVertices[i + 1] += moveVec.y;
		mVertices[i + 2] += moveVec.z;
	}

	// Update center
	mCentre.x += moveVec.x;
	mCentre.y += moveVec.y;
	mCentre.z += moveVec.z;

	setVBDataSizeAndCount(); // Send updated data to GPU
}


void Shape::moveAlongX(float distance)
{
	moveAlongVector(glm::vec3(1.0f, 0.0f, 0.0f), distance);
}

void Shape::moveAlongY(float distance)
{
	moveAlongVector(glm::vec3(0.0f, 1.0f, 0.0f), distance);
}

void Shape::moveAlongZ(float distance)
{
	moveAlongVector(glm::vec3(0.0f, 0.0f, 1.0f), distance);
}

void Shape::snapShapeCentreToCircularOrbit(const Point& orbitCenter, const glm::vec3& axis, float radius)
{
	glm::vec3 normAxis = glm::normalize(axis);

	// Choose arbitrary vector not parallel to axis
	glm::vec3 arbitrary = (std::abs(normAxis.x) < 0.99f)
		? glm::vec3(1.0f, 0.0f, 0.0f)
		: glm::vec3(0.0f, 1.0f, 0.0f);

	// Create orthonormal basis (u, v) for orbit plane
	glm::vec3 u = glm::normalize(glm::cross(normAxis, arbitrary));
	glm::vec3 v = glm::normalize(glm::cross(normAxis, u));

	// Relative vector from orbit center to shape center
	glm::vec3 toCentre = glm::vec3(mCentre.x, mCentre.y, mCentre.z) - glm::vec3(orbitCenter.x, orbitCenter.y, orbitCenter.z);

	// Remove component along axis (project onto orbit plane)
	glm::vec3 planar = toCentre - glm::dot(toCentre, normAxis) * normAxis;

	// Normalize planar direction
	glm::vec3 direction = glm::length(planar) > 0.0f ? glm::normalize(planar) : u;

	// Compute new center on circle
	glm::vec3 newCentre = glm::vec3(orbitCenter.x, orbitCenter.y, orbitCenter.z) + direction * radius;

	// Apply height offset (original height along axis)
	float height = glm::dot(toCentre, normAxis);
	newCentre += height * normAxis;

	// Compute shift vector
	glm::vec3 delta = newCentre - glm::vec3(mCentre.x, mCentre.y, mCentre.z);

	// Move shape
	for (size_t i = 0; i < mVertices.size(); i += 3)
	{
		mVertices[i + 0] += delta.x;
		mVertices[i + 1] += delta.y;
		mVertices[i + 2] += delta.z;
	}

	mCentre.x = newCentre.x;
	mCentre.y = newCentre.y;
	mCentre.z = newCentre.z;

	setVBDataSizeAndCount(); // Upload updated positions
}

void Shape::revolveAroundAxis(const Point& point, const glm::vec3& axis, float angleDegrees)
{
	glm::vec3 centerPoint(point.x, point.y, point.z);
	glm::vec3 normAxis = glm::normalize(axis);
	glm::mat4 rotation = glm::rotate(glm::mat4(1.0f), glm::radians(angleDegrees), normAxis);

	for (size_t i = 0; i < mVertices.size(); i += mVBL.getStride())
	{
		// Position
		glm::vec3 vertex(mVertices[i], mVertices[i + 1], mVertices[i + 2]);
		vertex -= centerPoint;
		vertex = glm::vec3(rotation * glm::vec4(vertex, 1.0f));
		vertex += centerPoint;

		mVertices[i] = vertex.x;
		mVertices[i + 1] = vertex.y;
		mVertices[i + 2] = vertex.z;

		// Normal
		glm::vec3 normal(mVertices[i + 3], mVertices[i + 4], mVertices[i + 5]);
		normal = glm::vec3(rotation * glm::vec4(normal, 0.0f));
		normal = glm::normalize(normal);

		mVertices[i + 3] = normal.x;
		mVertices[i + 4] = normal.y;
		mVertices[i + 5] = normal.z;
	}

	// Rotate the center point as well
	glm::vec3 centerVec(mCentre.x, mCentre.y, mCentre.z);
	centerVec -= centerPoint;
	centerVec = glm::vec3(rotation * glm::vec4(centerVec, 1.0f));
	centerVec += centerPoint;

	mCentre.x = centerVec.x;
	mCentre.y = centerVec.y;
	mCentre.z = centerVec.z;

	setVBDataSizeAndCount();
}


void Shape::revolveAroundXaxis(const Point& point, float angleDegrees)
{
	revolveAroundAxis(point, glm::vec3(1.0f, 0.0f, 0.0f), angleDegrees);
}

void Shape::revolveAroundYaxis(const Point& point, float angleDegrees)
{
	revolveAroundAxis(point, glm::vec3(0.0f, 1.0f, 0.0f), angleDegrees);
}

void Shape::revolveAroundZaxis(const Point& point, float angleDegrees)
{
	revolveAroundAxis(point, glm::vec3(0.0f, 0.0f, 1.0f), angleDegrees);
}

void Shape::snapShapeCentreToEllipticalOrbit(const Point& ellipseCenter, const glm::vec3& axis, float semiMajorRadius, float semiMinorRadius)
{
	glm::vec3 normAxis = glm::normalize(axis);

	// Create u-v basis perpendicular to axis
	glm::vec3 arbitrary = (std::abs(normAxis.x) < 0.99f)
		? glm::vec3(1.0f, 0.0f, 0.0f)
		: glm::vec3(0.0f, 1.0f, 0.0f);
	glm::vec3 u = glm::normalize(glm::cross(normAxis, arbitrary));
	glm::vec3 v = glm::normalize(glm::cross(normAxis, u));

	// Project current centre relative to ellipse center
	glm::vec3 c = glm::vec3(mCentre.x, mCentre.y, mCentre.z) - glm::vec3(ellipseCenter.x, ellipseCenter.y, ellipseCenter.z);
	float cu = glm::dot(c, u);
	float cv = glm::dot(c, v);

	// Normalize in ellipse space (a, b) to force point onto ellipse
	float ellipseAngle = std::atan2(cv / semiMinorRadius, cu / semiMajorRadius);
	glm::vec3 closestOnEllipse = semiMajorRadius * std::cos(ellipseAngle) * u + semiMinorRadius * std::sin(ellipseAngle) * v;

	// Preserve height along axis
	float height = glm::dot(c, normAxis);
	glm::vec3 newCentre = glm::vec3(ellipseCenter.x, ellipseCenter.y, ellipseCenter.z) + closestOnEllipse + height * normAxis;

	// Compute offset
	glm::vec3 delta = newCentre - glm::vec3(mCentre.x, mCentre.y, mCentre.z);

	// Apply offset to all vertices and center
	for (size_t i = 0; i < mVertices.size(); i += 3)
	{
		mVertices[i + 0] += delta.x;
		mVertices[i + 1] += delta.y;
		mVertices[i + 2] += delta.z;
	}

	mCentre.x = newCentre.x;
	mCentre.y = newCentre.y;
	mCentre.z = newCentre.z;

	setVBDataSizeAndCount(); // Upload updated positions
}

void Shape::revolveEllipticallyAroundAxis(const Point& center, const glm::vec3& axis, float angleDegrees, float semiMajorRadius, float semiMinorRadius)
{
	snapShapeCentreToEllipticalOrbit(center, axis, semiMajorRadius, semiMinorRadius);

	glm::vec3 normalizedAxis = glm::normalize(axis);

	glm::vec3 arbitrary = (std::abs(normalizedAxis.x) < 0.99f)
		? glm::vec3(1.0f, 0.0f, 0.0f)
		: glm::vec3(0.0f, 1.0f, 0.0f);

	glm::vec3 u = glm::normalize(glm::cross(normalizedAxis, arbitrary));
	glm::vec3 v = glm::normalize(glm::cross(normalizedAxis, u));

	float angleRad = glm::radians(angleDegrees);
	glm::vec3 offset = semiMajorRadius * cos(angleRad) * u + semiMinorRadius * sin(angleRad) * v;

	glm::mat4 rotation = glm::rotate(glm::mat4(1.0f), glm::radians(angleDegrees), normalizedAxis);

	for (size_t i = 0; i < mVertices.size(); i += mVBL.getStride())
	{
		glm::vec3 vertex(mVertices[i], mVertices[i + 1], mVertices[i + 2]);
		glm::vec3 direction = vertex - glm::vec3(center.x, center.y, center.z);
		float distance = glm::length(direction);

		glm::vec3 newPos = glm::vec3(center.x, center.y, center.z) + offset + normalizedAxis * glm::dot(direction, normalizedAxis);
		mVertices[i] = newPos.x;
		mVertices[i + 1] = newPos.y;
		mVertices[i + 2] = newPos.z;

		// Rotate normal
		glm::vec3 normal(mVertices[i + 3], mVertices[i + 4], mVertices[i + 5]);
		normal = glm::vec3(rotation * glm::vec4(normal, 0.0f));
		normal = glm::normalize(normal);

		mVertices[i + 3] = normal.x;
		mVertices[i + 4] = normal.y;
		mVertices[i + 5] = normal.z;
	}

	// Move centre of shape as well
	glm::vec3 centerVec(mCentre.x, mCentre.y, mCentre.z);
	glm::vec3 direction = centerVec - glm::vec3(center.x, center.y, center.z);
	float projection = glm::dot(direction, normalizedAxis);
	glm::vec3 newCenter = glm::vec3(center.x, center.y, center.z) + offset + normalizedAxis * projection;

	mCentre.x = newCenter.x;
	mCentre.y = newCenter.y;
	mCentre.z = newCenter.z;

	setVBDataSizeAndCount(); // Upload updated vertices
}

// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Shape.h =====
#pragma once

#include <vector>
#include "VertexArray.h"
#include "IndexBuffer.h"
#include "Program.h"
#include "Renderer.h"
#include "Point.h"
#include "Globals.h"
#include "Texture.h"

constexpr float PI = 3.14159265358979323846;

enum ShapeProgram
{
	SHAPE_FILL = 0, SHAPE_EDGE
};

class Shape
{
protected:
	Point mCentre;
	std::vector<float>mVertices;
	std::vector<unsigned int>mIndices;
	VertexArray mVA;
	VertexBuffer mVB;
	VertexBufferLayout mVBL;
	IndexBuffer mIB;
	Program fillProgram;
	Program edgeProgram;
	glm::mat4 mModel;
	glm::vec3 mColor;
	Texture* mTexture = nullptr;
	bool mHasTexture = false;

	void setVBDataSizeAndCount();
	void setVBLLayout3Floats();
	void setVBLLayout3Pos3Norm();
	void setVBLayout3Pos3Norm2Tex();
	virtual void setLayout();
	void setVABufferAndLayout();
	void setIBDataAndSize();

	void build();

public:

	Shape();
	Shape(float x, float y, float z);
	Shape(const Point& centre);
	Shape(const Point& centre, const glm::vec3& color);
	Shape(float x, float y, float z, glm::mat4 mat);
	Shape(float x, float y, float z, glm::mat4 mat, const glm::vec3& color);
	~Shape();

	virtual void generateVerticesAndIndices() = 0;

	void setPrograms(const Program* const fill, const Program* const edge);
	void setFillProgram(const Program* const fill);
	void setEdgeProgram(const Program* const edge);
	void setPrograms(const char* fillVertexSrc, const char* fillFragmentSrc, const char* edgeVertexSrc, const char* edgeFragmentSrc);
	void setFillProgram(const char* fillVertexSrc, const char* fillFragmentSrc);
	void setEdgeProgram(const char* edgeVertexSrc, const char* edgeFragmentSrc);

	void setModelMatrix(const glm::mat4& matrix);
	void setViewMatrix(const glm::mat4& matrix);
	void setProjectionMatrix(const glm::mat4& matrix);

	void setCameraViewPositionVector(const glm::vec3& vec);
	void setLightPositionVector(const glm::vec3& vec);
	void setLightColorVector(const glm::vec3& vec);
	void setObjectColorVector(const glm::vec3& vec);

	void setUniform1i(const char* name, int value);
	void setUniform1f(const char* name, float value);
	void setUniform3f(const char* name, float v0, float v1, float v2);
	void setUniformVector3fv(const char* name, const glm::vec3& vec);
	void setUniformMatrix4fv(const char* name, const glm::mat4& matrix);
	void setUniform1i(ShapeProgram prog, const char* name, int value);
	void setUniform1f(ShapeProgram prog, const char* name, float value);
	void setUniform3f(ShapeProgram prog, const char* name, float v0, float v1, float v2);
	void setUniformVector3fv(ShapeProgram prog, const char* name, const glm::vec3& vec);
	void setUniformMatrix4fv(ShapeProgram prog, const char* name, const glm::mat4& matrix);

	void setStaticUniforms();
	void setDynamicUniforms();
	void setAllUniforms();

	void setColor(float red, float green, float blue);
	void setColor(const Point& color);
	void setColor(const glm::vec3& color);

	void setUseTexture();
	void setTexture(Texture* tex);
	void setTexture(const std::string& path);

	void draw3D();
	void draw2D();

	void rotateAroundAxis(const glm::vec3& axis, float angleDegrees);
	void rotateAroundXaxis(float angleDegrees);
	void rotateAroundYaxis(float angleDegrees);
	void rotateAroundZaxis(float angleDegrees);

	void moveAlongVector(const glm::vec3& dir, float distance);
	void moveAlongX(float distance);
	void moveAlongY(float distance);
	void moveAlongZ(float distance);
	
	void snapShapeCentreToCircularOrbit(const Point& orbitCenter, const glm::vec3& axis, float radius);
	void revolveAroundAxis(const Point& point, const glm::vec3& axis, float angleDegrees);
	void revolveAroundXaxis(const Point& point, float angleDegrees);
	void revolveAroundYaxis(const Point& point, float angleDegrees);
	void revolveAroundZaxis(const Point& point, float angleDegrees);

	void snapShapeCentreToEllipticalOrbit(const Point& ellipseCenter, const glm::vec3& axis, float semiMajorRadius, float semiMinorRadius);
	void revolveEllipticallyAroundAxis(const Point& center, const glm::vec3& axis, float angleDegrees, float semiMajorRadius, float semiMinorRadius);
};

// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Shpere.cpp =====
#include "Sphere.h"

Sphere::Sphere(float radius)
	: Shape(), mRadius(radius)
{
	Shape::build();
}

Sphere::Sphere(float radius, float centreX, float centreY, float centreZ)
	: Shape(centreX, centreY, centreZ), mRadius(radius)
{
	Shape::build();
}

Sphere::Sphere(float radius, const Point& centre)
	:Shape(centre), mRadius(radius)
{
	Shape::build();
}

void Sphere::generateVerticesAndIndices()
{
    mVertices.clear();
    mIndices.clear();

    constexpr unsigned int stacks = 32, slices = 32;
    glm::vec3 sphereCentre(mCentre.x, mCentre.y, mCentre.z);

    for (unsigned int i = 0; i <= stacks; ++i) {
        float phi = PI * static_cast<float>(i) / static_cast<float>(stacks);

        for (unsigned int j = 0; j <= slices; ++j) {
            float theta = 2.0f * PI * static_cast<float>(j) / static_cast<float>(slices);

            float x = sin(phi) * cos(theta);
            float y = cos(phi);
            float z = sin(phi) * sin(theta);

            glm::vec3 normal = glm::normalize(glm::vec3(x, y, z));
            glm::vec3 position = sphereCentre + mRadius * normal;

            // Texture coordinates (u,v)
            float u = static_cast<float>(j) / static_cast<float>(slices);
            float v = static_cast<float>(i) / static_cast<float>(stacks);

            // Store position
            mVertices.push_back(position.x);
            mVertices.push_back(position.y);
            mVertices.push_back(position.z);

            // Store normal
            mVertices.push_back(normal.x);
            mVertices.push_back(normal.y);
            mVertices.push_back(normal.z);

            // Store texture coordinates
            mVertices.push_back(u);
            mVertices.push_back(v);
        }
    }

    // Generate indices
    for (unsigned int i = 0; i < stacks; ++i) {
        for (unsigned int j = 0; j < slices; ++j) {
            unsigned int first = i * (slices + 1) + j;
            unsigned int second = first + slices + 1;
                
            // First triangle
            mIndices.push_back(first);
            mIndices.push_back(second);
            mIndices.push_back(first + 1);

            // Second triangle
            mIndices.push_back(second);
            mIndices.push_back(second + 1);
            mIndices.push_back(first + 1);
        }
    }
}




// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Sphere.cpp =====


// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Sphere.h =====
#pragma once

#include "Shape.h"

class Sphere : public Shape
{
	float mRadius;
public:
	Sphere(float radius);
	Sphere(float radius, float centreX, float centreY, float centreZ);
	Sphere(float radius, const Point& centre);

	void generateVerticesAndIndices() override;
};


// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Texture.cpp =====
#include "Texture.h"
#include<GL/glew.h>

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

Texture::Texture(const std::string& path) {
    unsigned char* buffer = stbi_load(path.c_str(), &width, &height, &bpp, 4);
    glGenTextures(1, &ID);
    glBindTexture(GL_TEXTURE_2D, ID);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0,
        GL_RGBA, GL_UNSIGNED_BYTE, buffer);
    glBindTexture(GL_TEXTURE_2D, 0);
    stbi_image_free(buffer);
}

Texture::~Texture() {
    glDeleteTextures(1, &ID);
}

void Texture::bind(unsigned int slot) const {
    glActiveTexture(GL_TEXTURE0 + slot);
    glBindTexture(GL_TEXTURE_2D, ID);
}

void Texture::unBind() const {
    glBindTexture(GL_TEXTURE_2D, 0);
}


// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Texture.h =====
#pragma once
#include<string>

class Texture {
public:
    Texture(const std::string& imagePath);
    ~Texture();
    void bind(unsigned int slot = 0) const;
    void unBind() const;
private:
    unsigned int ID;
    int width, height, bpp;
};


// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\Triangle.cpp =====


// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\VectorBufferLayout.cpp =====
#include "VertexBufferLayout.h"

VertexBufferLayout::VertexBufferLayout()
	: stride(0)
{}

const std::vector<VertexBufferLayoutElement>& VertexBufferLayout::getElements() const
{
	return elements;
}

unsigned int VertexBufferLayout::getStride() const
{
	return stride;
}


// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\VertexArray.cpp =====
#include "VertexArray.h"
#include "VertexBufferLayout.h"
#include "VertexBufferLayoutElement.h"
#include <GL/glew.h>

VertexArray::VertexArray()
{
	glGenVertexArrays(1, &ID);
}

VertexArray::~VertexArray()
{
	glDeleteVertexArrays(1, &ID);
}

void VertexArray::addBufferAndLayout(const VertexBuffer& vb, const VertexBufferLayout& layout)
{
	bind();
	vb.bind();
	const auto& elements = layout.getElements();
	unsigned int offset = 0;
	for (int i = 0; i < elements.size(); i++) 
	{
		const auto& element = elements[i];
		glVertexAttribPointer(i, element.getCount(), element.getType(), element.getNormalized(), layout.getStride(), (void*)offset);
		glEnableVertexAttribArray(i);
		offset += element.getCount() * VertexBufferLayoutElement::getTypeSize(element.getType());
	}
}

void VertexArray::bind() const
{
	glBindVertexArray(ID);
}

void VertexArray::unbind() const
{
	glBindVertexArray(0);
}


// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\VertexArray.h =====
#pragma once
#include "VertexBuffer.h"
#include "VertexBufferLayout.h"

class VertexArray
{
	unsigned int ID;
public:
	VertexArray();
	~VertexArray();

	void addBufferAndLayout(const VertexBuffer& vb, const VertexBufferLayout& layout);
	void bind() const;
	void unbind() const;
};

// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\VertexBuffer.cpp =====
#include "VertexBuffer.h"
#include <GL/glew.h>

VertexBuffer::VertexBuffer()
	: vertexCount(0)
{
	glGenBuffers(1, &ID);
}

VertexBuffer::VertexBuffer(const void* data, unsigned int size, unsigned int cnt)
	: vertexCount(cnt)
{
	glGenBuffers(1, &ID);
	glBindBuffer(GL_ARRAY_BUFFER, ID);
	glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);
}

VertexBuffer::~VertexBuffer()
{
	glDeleteBuffers(1, &ID);
}

void VertexBuffer::setDataSizeAndCount(const void* data, unsigned int size, unsigned int cnt)
{
	vertexCount = cnt;
	glBindBuffer(GL_ARRAY_BUFFER, ID);
	glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);
}

void VertexBuffer::bind() const
{
	glBindBuffer(GL_ARRAY_BUFFER, ID);
}

void VertexBuffer::unbind() const
{
	glBindBuffer(GL_ARRAY_BUFFER, 0);
}

unsigned int VertexBuffer::getCount() const
{
	return vertexCount;
}

// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\VertexBuffer.h =====
#pragma once

class VertexBuffer
{
	unsigned int ID;
	unsigned int vertexCount;
public:
	VertexBuffer();
	VertexBuffer(const void* data, unsigned int size, unsigned int cnt);
	~VertexBuffer();

	void setDataSizeAndCount(const void* data, unsigned int size, unsigned int cnt);
	void bind() const;
	void unbind() const;
	unsigned int getCount() const;
};


// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\VertexBufferLayout.h =====
#pragma once
#include <GL/glew.h>
#include "VertexBufferLayoutElement.h"
#include <vector>

class VertexBufferLayout
{
	unsigned int stride;
	std::vector<VertexBufferLayoutElement> elements;

public:
	VertexBufferLayout();
	const std::vector<VertexBufferLayoutElement>& getElements() const;
	unsigned int getStride() const;

	template<typename T>
	void push(unsigned int count);

	template<>
	void push<float>(unsigned int count)
	{
		elements.push_back({GL_FLOAT, count, GL_FALSE});
		stride += count * VertexBufferLayoutElement::getTypeSize(GL_FLOAT);
	}

	template<>
	void push<unsigned int>(unsigned int count)
	{
		elements.push_back({ GL_UNSIGNED_INT, count, GL_FALSE });
		stride += count * VertexBufferLayoutElement::getTypeSize(GL_UNSIGNED_INT);
	}

	template<>
	void push<unsigned char>(unsigned int count)
	{
		elements.push_back({ GL_UNSIGNED_BYTE, count, GL_TRUE });
		stride += count * VertexBufferLayoutElement::getTypeSize(GL_UNSIGNED_BYTE);
	}

};

// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\VertexBufferLayoutElement.cpp =====
#include "VertexBufferLayoutElement.h"
#include <GL/glew.h>

VertexBufferLayoutElement::VertexBufferLayoutElement(unsigned int type, unsigned int count, unsigned char normalized)
    : m_type(type), m_count(count), m_normalized(normalized)
{}

unsigned int VertexBufferLayoutElement::getTypeSize(unsigned int type)
{
    switch (type)
    {
        case GL_FLOAT: return 4;
        case GL_UNSIGNED_INT: return 4;
        case GL_UNSIGNED_BYTE: return 1;
    }
    return 0;
}

unsigned int VertexBufferLayoutElement::getType() const
{
    return m_type;
}
unsigned int VertexBufferLayoutElement::getCount() const
{
    return m_count;
}
unsigned char VertexBufferLayoutElement::getNormalized() const
{
    return m_normalized;
}


// ===== File: C:\Users\shrir\source\repos\Gravity Simulation\Gravity Simulation\VertexBufferLayoutElement.h =====
#pragma once

class VertexBufferLayoutElement
{
	unsigned int m_type;
	unsigned int m_count;
	unsigned char m_normalized;

public:
	VertexBufferLayoutElement(unsigned int type, unsigned int count, unsigned char normalized);

	static unsigned int getTypeSize(unsigned int type);
	unsigned int getType() const;
	unsigned int getCount() const;
	unsigned char getNormalized() const;
};
